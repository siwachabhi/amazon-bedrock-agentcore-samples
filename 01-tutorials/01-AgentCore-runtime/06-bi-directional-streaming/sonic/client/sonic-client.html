<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nova Sonic WebSocket Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
            margin: 0;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            height: calc(100vh - 20px);
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .header-text {
            text-align: left;
        }
        
        .header h1 {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 0;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .header p {
            display: none;
        }
        
        .content {
            padding: 10px 15px;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        #status { 
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 10px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            min-width: 100px;
            text-align: center;
        }
        
        .connected { 
            background: rgba(129, 199, 132, 0.95);
            color: white;
        }
        
        .disconnected { 
            background: rgba(229, 115, 115, 0.95);
            color: white;
        }
        
        #controls { 
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            max-width: 200px;
        }
        
        button { 
            flex: 1;
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 1px 4px rgba(0,0,0,0.15);
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }
        
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #toggleBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        #toggleBtn.connected {
            background: linear-gradient(135deg, #e57373 0%, #ef5350 100%);
        }
        
        .config-section {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            gap: 8px;
            align-items: flex-end;
        }
        
        .form-group {
            margin-bottom: 0;
            flex: 1;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 2px;
            font-weight: 600;
            color: #333;
            font-size: 10px;
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 11px;
            transition: all 0.3s ease;
            font-family: inherit;
            background: white;
        }
        
        .form-group small {
            display: none;
        }
        
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        #textInput {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.3s ease;
            font-family: inherit;
        }
        
        #textInput:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }
        
        #textInput:disabled {
            background: #f5f5f5;
            cursor: not-allowed;
        }
        
        #sendBtn {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            color: white;
            padding: 6px 16px;
            flex: 0 0 auto;
        }
        
        .panels-container { 
            display: flex;
            gap: 15px;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }
        
        .panel { 
            flex: 1;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .panel h2 { 
            margin: 0;
            padding: 6px 10px;
            font-size: 12px;
            font-weight: 700;
            color: white;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-bottom: none;
            flex-shrink: 0;
        }
        
        .panel-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            flex-shrink: 0;
        }
        
        .event-filter {
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.2);
        }
        
        .event-filter input {
            width: 100%;
            padding: 4px 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 11px;
            font-family: inherit;
        }
        
        .event-filter input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .event-filter input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }
        
        .event.hidden {
            display: none;
        }
        
        #messages { 
            height: 0;
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 10px;
            background: #fafafa;
        }
        
        #messages::-webkit-scrollbar,
        #events::-webkit-scrollbar {
            width: 8px;
        }
        
        #messages::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        #messages::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }
        
        .message { 
            margin: 4px 0;
            padding: 6px 10px;
            border-radius: 10px;
            max-width: 80%;
            animation: slideIn 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            font-size: 12px;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .user { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin-left: auto;
            text-align: right;
        }
        
        .assistant { 
            background: white;
            border: 2px solid #e0e0e0;
            color: #333;
        }
        
        .system { 
            background: linear-gradient(135deg, #fff9c4 0%, #fff59d 100%);
            color: #f57f17;
            font-style: italic;
            text-align: center;
            margin: 10px auto;
            max-width: 60%;
            font-size: 12px;
        }
        
        .tool { 
            background: linear-gradient(135deg, #c8e6c9 0%, #a5d6a7 100%);
            color: #2e7d32;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        #events { 
            height: 0;
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 8px;
            background: #1e1e1e;
            font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;
            font-size: 10px;
        }
        
        #events::-webkit-scrollbar-track {
            background: #2d2d2d;
        }
        
        #events::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }
        
        .event { 
            margin: 3px 0;
            padding: 5px 8px;
            border-left: 2px solid #667eea;
            background: #2d2d2d;
            color: #d4d4d4;
            border-radius: 3px;
            animation: slideIn 0.2s ease;
        }
        
        .event.sent { 
            border-left-color: #4caf50;
            background: #1a2e1a;
        }
        
        .event.received { 
            border-left-color: #2196f3;
            background: #1a2533;
        }
        
        .event-type { 
            color: #ffa726;
            font-weight: bold;
            font-size: 10px;
            margin-bottom: 2px;
        }
        
        .event-time { 
            color: #9e9e9e;
            font-size: 8px;
            margin-bottom: 2px;
        }
        
        .event-data { 
            color: #81c784;
            margin-top: 2px;
            white-space: pre-wrap;
            word-break: break-all;
            line-height: 1.3;
            font-size: 9px;
        }
        
        .event-data.audio-event {
            max-height: 100px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .event-data.audio-event::-webkit-scrollbar {
            width: 4px;
        }
        
        .event-data.audio-event::-webkit-scrollbar-track {
            background: #1e1e1e;
        }
        
        .event-data.audio-event::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-text">
                <h1>üéôÔ∏è Nova Sonic S2S WebSocket Client - with Bedrock AgentCore</h1>
            </div>
            <div id="status" class="disconnected">Disconnected</div>
        </div>
        
        <div class="content">
            <div class="config-section">
                <div class="form-group">
                    <label for="websocketUrl">üîó WebSocket URL</label>
                    <input type="text" id="websocketUrl" placeholder="ws://localhost:8081/ws" value="ws://localhost:8081/ws">
                    <small style="color: #666; font-size: 12px; margin-top: 4px; display: block;">
                        Enter the WebSocket server URL (default: ws://localhost:8081/ws)
                    </small>
                </div>
                <div class="form-group">
                    <label for="voiceSelect">üé§ Voice</label>
                    <select id="voiceSelect" onchange="changeVoice()">
                        <optgroup label="üá∫üá∏üá¨üáßüá¶üá∫ English">
                            <option value="tiffany">Tiffany (US, Female, Polyglot)</option>
                            <option value="matthew" selected>Matthew (US, Male)</option>
                            <option value="amy">Amy (UK, Female)</option>
                            <option value="olivia">Olivia (AU, Female)</option>
                        </optgroup>
                        <optgroup label="üá´üá∑ French">
                            <option value="florian">Florian (FR, Male, Polyglot)</option>
                            <option value="ambre">Ambre (FR, Female, Polyglot)</option>
                        </optgroup>
                        <optgroup label="üáÆüáπ Italian">
                            <option value="lorenzo">Lorenzo (IT, Male, Polyglot)</option>
                            <option value="beatrice">Beatrice (IT, Female, Polyglot)</option>
                        </optgroup>
                        <optgroup label="üá©üá™ German">
                            <option value="lennart">Lennart (DE, Male, Polyglot)</option>
                            <option value="greta">Greta (DE, Female, Polyglot)</option>
                        </optgroup>
                        <optgroup label="üá™üá∏üá∫üá∏ Spanish">
                            <option value="carlos">Carlos (US/ES, Male, Polyglot)</option>
                            <option value="lupe">Lupe (US/ES, Female, Polyglot)</option>
                        </optgroup>
                    </select>
                </div>
            </div>
            
            <div id="controls">
                <button id="toggleBtn" onclick="toggleConnection()">üöÄ Start Conversation</button>
            </div>
            
            <div class="panels-container">
                <div class="panel">
                    <h2>üí¨ Conversation</h2>
                    <div id="messages"></div>
                </div>
                <div class="panel">
                    <div class="panel-header">
                        <h2>üì° Events</h2>
                        <div class="event-filter">
                            <input type="text" id="eventFilter" placeholder="üîç Filter events by keyword..." oninput="filterEvents()" />
                        </div>
                    </div>
                    <div id="events"></div>
                </div>
            </div>
        </div>
    </div>
    <script>
        let ws = null;
        let audioContext = null;
        let isRecording = false;
        let audioPlaybackContext = null;
        let nextPlayTime = 0;
        let promptName = null;
        let audioContentName = null;
        let textContentName = null;
        let currentGenerationStage = null;  // Track generation stage from contentStart
        let sessionStarted = false;  // Track if session has been started
    
        function filterEvents() {
            const filterInput = document.getElementById('eventFilter');
            const filterText = filterInput.value.toLowerCase();
            const events = document.querySelectorAll('#events .event');
            
            events.forEach(event => {
                const eventText = event.textContent.toLowerCase();
                if (eventText.includes(filterText)) {
                    event.classList.remove('hidden');
                } else {
                    event.classList.add('hidden');
                }
            });
        }
    
        function addMessage(content, type) {
            const messages = document.getElementById('messages');
            const message = document.createElement('div');
            message.className = 'message ' + type;
            message.textContent = content;
            messages.appendChild(message);
            messages.scrollTop = messages.scrollHeight;
        }
        
        function addEvent(direction, type, data) {
            const events = document.getElementById('events');
            const event = document.createElement('div');
            event.className = 'event ' + direction;
            
            const time = new Date().toLocaleTimeString();
            const arrow = direction === 'sent' ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è';
            const dataStr = typeof data === 'object' ? JSON.stringify(data, null, 2) : data;
            
            const isAudioEvent = type === 'audioInput' || type === 'audioOutput';
            const dataClass = isAudioEvent ? 'event-data audio-event' : 'event-data';
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'event-time';
            timeDiv.textContent = `${time} ${arrow}`;

            const typeDiv = document.createElement('div');
            typeDiv.className = 'event-type';
            typeDiv.textContent = type;

            const dataDiv = document.createElement('div');
            dataDiv.className = dataClass;
            dataDiv.textContent = dataStr;

            event.appendChild(timeDiv);
            event.appendChild(typeDiv);
            event.appendChild(dataDiv);
            
            events.appendChild(event);
            events.scrollTop = events.scrollHeight;
        }
    
        function updateStatus(connected, recording = false) {
            const status = document.getElementById('status');
            const toggleBtn = document.getElementById('toggleBtn');
            
            if (connected) {
                status.textContent = recording ? 'üî¥ Recording' : 'üü¢ Connected';
                status.className = 'connected';
                toggleBtn.textContent = 'üõë End Conversation';
                toggleBtn.className = 'connected';
                toggleBtn.disabled = false;
            } else {
                status.textContent = '‚ö´ Disconnected';
                status.className = 'disconnected';
                toggleBtn.textContent = 'üöÄ Start Conversation';
                toggleBtn.className = '';
                toggleBtn.disabled = false;
            }
        }
        
        function toggleConnection() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                disconnect();
            } else {
                connect();
            }
        }
        
        function changeVoice() {
            // Only send voice change if session is active
            if (!ws || ws.readyState !== WebSocket.OPEN || !sessionStarted) {
                return;
            }
            
            const selectedVoice = document.getElementById('voiceSelect').value;
            const voiceLabel = document.getElementById('voiceSelect').selectedOptions[0].text;
            
            // Send a new promptStart with updated voiceId
            const promptStart = {
                event: {
                    promptStart: {
                        promptName: promptName,
                        textOutputConfiguration: {
                            mediaType: "text/plain"
                        },
                        audioOutputConfiguration: {
                            mediaType: "audio/lpcm",
                            sampleRateHertz: 24000,
                            sampleSizeBits: 16,
                            channelCount: 1,
                            voiceId: selectedVoice,
                            encoding: "base64",
                            audioType: "SPEECH"
                        },
                        toolUseOutputConfiguration: {
                            mediaType: "application/json"
                        },
                        toolConfiguration: {
                            "tools": [
                                {
                                    "toolSpec": {
                                        "name": "getDateTool",
                                        "description": "get information about the current day",
                                        "inputSchema": {
                                            "json": JSON.stringify({
                                                "type": "object",
                                                "properties": {},
                                                "required": []
                                            })
                                        }
                                    }
                                }
                            ]
                        }
                    }
                }
            };
            
            ws.send(JSON.stringify(promptStart));
            addEvent('sent', 'promptStart (voice change)', promptStart);
            addMessage(`üé§ Voice changed to: ${voiceLabel}`, 'system');
        }
    
        async function playAudioOutput(base64Audio, sampleRate) {
            if (!audioPlaybackContext) {
                audioPlaybackContext = new AudioContext({ sampleRate: sampleRate });
                nextPlayTime = audioPlaybackContext.currentTime;
            }
            
            if (audioPlaybackContext.state === 'suspended') {
                await audioPlaybackContext.resume();
            }
    
            const binaryString = atob(base64Audio);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
    
            const int16Data = new Int16Array(bytes.buffer);
            const float32Data = new Float32Array(int16Data.length);
            for (let i = 0; i < int16Data.length; i++) {
                float32Data[i] = int16Data[i] / 32768.0;
            }
    
            const buffer = audioPlaybackContext.createBuffer(1, float32Data.length, sampleRate);
            buffer.getChannelData(0).set(float32Data);
            
            const currentTime = audioPlaybackContext.currentTime;
            if (nextPlayTime < currentTime) {
                nextPlayTime = currentTime;
            }
            
            const source = audioPlaybackContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioPlaybackContext.destination);
            source.start(nextPlayTime);
            nextPlayTime += buffer.duration;
        }
    
        function generateId(length = 10) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            return Array.from({ length }, () => 
                chars.charAt(Math.floor(Math.random() * chars.length))
            ).join('');
        }
        
        async function connect() {
            // Disable button while connecting
            const toggleBtn = document.getElementById('toggleBtn');
            toggleBtn.disabled = true;
            toggleBtn.textContent = '‚è≥ Starting...';
            
            document.getElementById('messages').textContent = '';
            document.getElementById('events').textContent = '';
            
            const websocketUrl = document.getElementById('websocketUrl').value.trim();
            
            if (!websocketUrl) {
                addMessage('‚ùå Error: WebSocket URL is required', 'system');
                toggleBtn.disabled = false;
                toggleBtn.textContent = 'üöÄ Start Conversation';
                return;
            }
            
            const displayUrl = websocketUrl.length > 100 ? websocketUrl.substring(0, 100) + '...' : websocketUrl;
            addMessage(`üîó Connecting to: ${displayUrl}`, 'system');
            
            try {
                ws = new WebSocket(websocketUrl);
                
                ws.onerror = (error) => {
                    addMessage(`‚ùå WebSocket error: ${error.message || 'Connection failed'}`, 'system');
                    console.error('WebSocket error:', error);
                    const toggleBtn = document.getElementById('toggleBtn');
                    toggleBtn.disabled = false;
                    toggleBtn.textContent = 'üöÄ Start Conversation';
                    updateStatus(false);
                };
            
                ws.onopen = async () => {
                    addMessage('‚úÖ Connected to Nova Sonic', 'system');
                    updateStatus(true);
                    
                    // Initialize session
                    promptName = 'prompt_' + generateId();
                    audioContentName = 'audio_' + generateId();
                    textContentName = 'text_' + generateId();
                    
                    // Send session start
                    const sessionStart = {
                        event: {
                            sessionStart: {
                                inferenceConfiguration: {
                                    maxTokens: 1024,
                                    topP: 0.95,
                                    temperature: 0.7
                                }
                            }
                        }
                    };
                    ws.send(JSON.stringify(sessionStart));
                    addEvent('sent', 'sessionStart', sessionStart);
                    
                    // Mark session as started
                    sessionStarted = true;
                    
                    // Wait a bit for server to process sessionStart
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Get selected voice
                    const selectedVoice = document.getElementById('voiceSelect').value;
                    
                    // Send prompt start
                    const promptStart = {
                        event: {
                            promptStart: {
                                promptName: promptName,
                                textOutputConfiguration: {
                                    mediaType: "text/plain"
                                },
                                audioOutputConfiguration: {
                                    mediaType: "audio/lpcm",
                                    sampleRateHertz: 24000,
                                    sampleSizeBits: 16,
                                    channelCount: 1,
                                    voiceId: selectedVoice,
                                    encoding: "base64",
                                    audioType: "SPEECH"
                                },
                                toolUseOutputConfiguration: {
                                    mediaType: "application/json"
                                },
                                toolConfiguration: {
                                    "tools": [
                                        {
                                            "toolSpec": {
                                                "name": "getDateTool",
                                                "description": "get information about the current day",
                                                "inputSchema": {
                                                    "json": JSON.stringify({
                                                        "type": "object",
                                                        "properties": {},
                                                        "required": []
                                                    })
                                                }
                                            }
                                        }
                                    ]
                                }
                            }
                        }
                    };
                    ws.send(JSON.stringify(promptStart));
                    addEvent('sent', 'promptStart', promptStart);
                    
                    // Send system prompt
                    const systemContentStart = {
                        event: {
                            contentStart: {
                                promptName: promptName,
                                contentName: textContentName,
                                type: "TEXT",
                                interactive: false,
                                role: "SYSTEM",
                                textInputConfiguration: {
                                    mediaType: "text/plain"
                                }
                            }
                        }
                    };
                    ws.send(JSON.stringify(systemContentStart));
                    addEvent('sent', 'contentStart (TEXT)', systemContentStart);
                    
                    const textInput = {
                        event: {
                            textInput: {
                                promptName: promptName,
                                contentName: textContentName,
                                content: "You are a friendly assistant. Keep your responses short, generally two or three sentences."
                            }
                        }
                    };
                    ws.send(JSON.stringify(textInput));
                    addEvent('sent', 'textInput', textInput);
                    
                    const systemContentEnd = {
                        event: {
                            contentEnd: {
                                promptName: promptName,
                                contentName: textContentName
                            }
                        }
                    };
                    ws.send(JSON.stringify(systemContentEnd));
                    addEvent('sent', 'contentEnd', systemContentEnd);
                    
                    // Start audio content
                    const audioContentStart = {
                        event: {
                            contentStart: {
                                promptName: promptName,
                                contentName: audioContentName,
                                type: "AUDIO",
                                interactive: true,
                                role: "USER",
                                audioInputConfiguration: {
                                    mediaType: "audio/lpcm",
                                    sampleRateHertz: 16000,
                                    sampleSizeBits: 16,
                                    channelCount: 1,
                                    audioType: "SPEECH",
                                    encoding: "base64"
                                }
                            }
                        }
                    };
                    ws.send(JSON.stringify(audioContentStart));
                    addEvent('sent', 'contentStart (AUDIO)', audioContentStart);
                    
                    // Wait a bit for server to process all setup events
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    // Start recording
                    await startRecording();
                };
            
                ws.onmessage = async (event) => {
                    const data = JSON.parse(event.data);
                    
                    if (!data.event) return;
                    
                    const eventType = Object.keys(data.event)[0];
                    const eventData = data.event[eventType];
                    
                    // Log received events (truncate audio)
                    if (eventType === 'audioOutput') {
                        addEvent('received', eventType, { ...eventData, content: `[${eventData.content?.length || 0} bytes]` });
                    } else {
                        addEvent('received', eventType, data);
                    }
                    
                    switch (eventType) {
                        case 'contentStart':
                            // Track generation stage from additionalModelFields
                            if (eventData.additionalModelFields) {
                                try {
                                    const modelFields = JSON.parse(eventData.additionalModelFields);
                                    currentGenerationStage = modelFields.generationStage;
                                } catch (e) {
                                    console.error('Failed to parse additionalModelFields:', e);
                                }
                            }
                            break;
                        case 'contentEnd':
                            // Handle interruption (barge-in)
                            if (eventData.stopReason === 'INTERRUPTION') {
                                addMessage('[Interrupted]', 'system');
                                // Stop audio playback immediately
                                if (audioPlaybackContext) {
                                    audioPlaybackContext.close();
                                    audioPlaybackContext = null;
                                    nextPlayTime = 0;
                                }
                            }
                            
                            // Reset generation stage when content ends
                            currentGenerationStage = null;
                            
                            // Log contentEnd with type AUDIO to console for debugging only
                            if (eventData.type === 'AUDIO') {
                                const stopReason = eventData.stopReason || 'unknown';
                                console.log(`Received contentEnd with type AUDIO, stopReason: ${stopReason}`);
                            }
                            break;
                        case 'interruption':
                            // Handle explicit interruption event (similar to strands bidi_interruption)
                            addMessage('[Interrupted]', 'system');
                            if (audioPlaybackContext) {
                                audioPlaybackContext.close();
                                audioPlaybackContext = null;
                                nextPlayTime = 0;
                            }
                            break;
                        case 'audioOutput':
                            await playAudioOutput(eventData.content, 24000);
                            break;
                        case 'textOutput':
                            // Display textOutput based on role and generationStage:
                            // - ASSISTANT: only when generationStage is SPECULATIVE
                            // - USER: only when generationStage is FINAL
                            const role = (eventData.role || 'ASSISTANT').toLowerCase();
                            const shouldDisplay = 
                                (role === 'assistant' && currentGenerationStage === 'SPECULATIVE') ||
                                (role === 'user' && currentGenerationStage === 'FINAL');
                            
                            if (shouldDisplay) {
                                const prefix = role === 'user' ? 'üé§ User' : 'üîä Assistant';
                                addMessage(`${prefix}: ${eventData.content}`, role);
                            }
                            break;
                        case 'toolUse':
                            addMessage(`üîß Tool: ${eventData.toolName}`, 'tool');
                            break;
                        case 'toolResult':
                            // Display tool result in conversation
                            let resultContent = eventData.content;
                            try {
                                // Try to parse and pretty-print JSON content
                                const parsed = JSON.parse(resultContent);
                                resultContent = JSON.stringify(parsed, null, 2);
                            } catch (e) {
                                // Not JSON, use as-is
                            }
                            addMessage(`üìä Tool Result:\n${resultContent}`, 'tool');
                            break;
                    }
                };
            
                ws.onclose = (event) => {
                    let reason = 'Unknown reason';
                    let details = '';
                    
                    // Decode close code
                    if (event.code === 1000) {
                        reason = 'Normal closure';
                    } else if (event.code === 1001) {
                        reason = 'Going away (browser navigating away or server shutting down)';
                    } else if (event.code === 1002) {
                        reason = 'Protocol error';
                    } else if (event.code === 1003) {
                        reason = 'Unsupported data';
                    } else if (event.code === 1006) {
                        reason = 'Abnormal closure (no close frame received)';
                        details = ' - This often indicates network issues, server crash, or expired presigned URL';
                    } else if (event.code === 1007) {
                        reason = 'Invalid frame payload data';
                    } else if (event.code === 1008) {
                        reason = 'Policy violation';
                    } else if (event.code === 1009) {
                        reason = 'Message too big';
                    } else if (event.code === 1010) {
                        reason = 'Missing extension';
                    } else if (event.code === 1011) {
                        reason = 'Internal server error';
                    } else if (event.code === 1015) {
                        reason = 'TLS handshake failure';
                    } else {
                        reason = `Unknown code: ${event.code}`;
                    }
                    
                    const closeReason = event.reason ? ` - ${event.reason}` : '';
                    const wasClean = event.wasClean ? 'Clean' : 'Unclean';
                    
                    console.log(`WebSocket closed: Code=${event.code}, Reason=${reason}, Clean=${event.wasClean}`);
                    console.log(`Event details:`, event);
                    
                    addMessage(`‚ùå Disconnected (${wasClean})`, 'system');
                    addMessage(`üìã Code ${event.code}: ${reason}${closeReason}${details}`, 'system');
                    addEvent('received', 'close', {
                        code: event.code,
                        reason: reason,
                        wasClean: event.wasClean,
                        customReason: event.reason || 'none'
                    });
                    
                    updateStatus(false);
                    if (isRecording) stopRecording();
                    if (audioPlaybackContext) {
                        audioPlaybackContext.close();
                        audioPlaybackContext = null;
                    }
                };
            } catch (error) {
                addMessage(`‚ùå Failed to connect: ${error.message}`, 'system');
                console.error('Connection error:', error);
                const toggleBtn = document.getElementById('toggleBtn');
                toggleBtn.disabled = false;
                toggleBtn.textContent = 'üöÄ Start Conversation';
                updateStatus(false);
            }
        }
    
        function disconnect() {
            if (isRecording) stopRecording();
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                // Send content end for audio
                const audioContentEnd = {
                    event: {
                        contentEnd: {
                            promptName: promptName,
                            contentName: audioContentName
                        }
                    }
                };
                ws.send(JSON.stringify(audioContentEnd));
                addEvent('sent', 'contentEnd', audioContentEnd);
                
                // Send prompt end
                const promptEnd = {
                    event: {
                        promptEnd: {
                            promptName: promptName
                        }
                    }
                };
                ws.send(JSON.stringify(promptEnd));
                addEvent('sent', 'promptEnd', promptEnd);
                
                // Send session end
                const sessionEnd = {
                    event: {
                        sessionEnd: {}
                    }
                };
                ws.send(JSON.stringify(sessionEnd));
                addEvent('sent', 'sessionEnd', sessionEnd);
            }
            
            if (ws) ws.close();
        }


    
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { channelCount: 1, echoCancellation: true, noiseSuppression: true } 
                });
                
                audioContext = new AudioContext();
                const source = audioContext.createMediaStreamSource(stream);
                const processor = audioContext.createScriptProcessor(4096, 1, 1);
                
                let audioChunkCount = 0;
                processor.onaudioprocess = (e) => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        const inputData = e.inputBuffer.getChannelData(0);
                        
                        // Downsample to 16kHz
                        const downsampleRatio = audioContext.sampleRate / 16000;
                        const outputLength = Math.floor(inputData.length / downsampleRatio);
                        const int16Data = new Int16Array(outputLength);
                        
                        for (let i = 0; i < outputLength; i++) {
                            const sourceIndex = Math.floor(i * downsampleRatio);
                            int16Data[i] = Math.max(-32768, Math.min(32767, inputData[sourceIndex] * 32768));
                        }
                        
                        const bytes = new Uint8Array(int16Data.buffer);
                        let binary = '';
                        for (let i = 0; i < bytes.length; i++) {
                            binary += String.fromCharCode(bytes[i]);
                        }
                        const base64Audio = btoa(binary);
                        
                        const payload = {
                            event: {
                                audioInput: {
                                    promptName: promptName,
                                    contentName: audioContentName,
                                    content: base64Audio
                                }
                            }
                        };
                        ws.send(JSON.stringify(payload));
                        
                        // Log audio chunks less frequently
                        audioChunkCount++;
                        if (audioChunkCount % 10 === 0) {
                            // Show raw event with full audio data
                            addEvent('sent', 'audioInput', payload);
                        }
                    }
                };
                
                source.connect(processor);
                processor.connect(audioContext.destination);
                
                isRecording = true;
                updateStatus(true, true);
                addMessage('üéôÔ∏è Session started - speak now', 'system');
            } catch (err) {
                addMessage('‚ùå Microphone access denied: ' + err.message, 'system');
            }
        }
        
        function stopRecording() {
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            isRecording = false;
            addMessage('‚èπÔ∏è Session stopped', 'system');
        }

    </script>
</body>
</html>
